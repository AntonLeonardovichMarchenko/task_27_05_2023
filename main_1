"""


# ========================================================================

Модули и пакеты...
Модули и пакеты в Python – инструменты для управления сложностью в программном
проекте. Главный технический императив программирования – это управление
сложностью: основная идея которого заключается в том, что на каждом этапе
разработки надо прикладывать максимум усилий для того чтобы сложность проекта
"оставалась минимальной".
Инструмент "декомпозиция" – разделение целого на части - этот принцип является
одним из наиболее часто используемых способов работать со сложностью.
Декомпозицию можно реализовывать на логическом и на физическом уровне.
Для реализации декомпозиции на физическом уровне в python
применяются модули и пакеты.
Модуль в Python - это файл с исходным кодом (с расширением .py).
Пакет – это каталог, который может включать другие каталоги или модули.
Модуль может содержать функции, классы, объекты классов и переменные
– все может быть доступно для других модулей, если правильно импортировать
исходный модуль. Также в модуле может содержаться программный код,
который будет выполняться, если скрипт будет запущен на исполнение.
Можно импортировать как весь модуль целиком, так его части.

Примеры...
Модули
Модуль с именем simplemath.py. Будет содержать функции для выполнения
простых арифметических действий.

# ========================================================================
simplemath.py  # имя модуля

def add(a, b):
   return a + b

def sub(a, b):
   return a - b

def mul(a, b):
   return a * b

def div(a, b):
   return a / b
# ========================================================================

Применение.
Ещё один модуль worker.py, который будет использовать функции
из simplemath.py. Если из simplemath нужно импортировать все функции
модуля worker.py - применяется оператор import.
# ========================================================================

worker.py

import simplemath

print("\"import\" sample")
print(simplemath.add(1, 2))
print(simplemath.sub(1, 2))
print(simplemath.mul(1, 2))
print(simplemath.div(1, 2))

# ========================================================================

Если d worker.py нужна только функция сложения, в таком случае можно
применить оператор from <_модуль_откуда_> import <_что_импортировать_>.
# ========================================================================

worker_from.py # имя модуля

from simplemath import add # из simplemath импортировать функцию add

print("\"from\" sample")
print(add(1, 2))

# print(sub(1, 2)) # а вот этого нелать нельзя!
                   # функция sub НЕ была импортирована из simplemath!

# ========================================================================
Теперь для вызова функции add() не надо необходимости указывать,
что она находится в модуле simplemath.
В первом случае мы ее вызывали так simplemath.add(1, 2),
теперь достаточно сделать так: add(1, 2). Вызов функций sub(),mult(), div()
становится невозможным, т.к. они не были импортированы.
# ========================================================================

Пакеты
Если в проекте создать папку mathpack и перенести туда модуль simplemath.py,
то для того, чтобы использовать simplemath, нужно изменить процедуру импорта.
Если просто добавить в оператор import simplemath название пакета в виде префикса,
то тогда нужно будет модифицировать все места вызова функций из simplemath.

# ========================================================================

worker_pack.py

import mathpack.simplemath

print("\"import\" sample")
print(mathpack.simplemath.add(1, 2))
print(mathpack.simplemath.sub(1, 2))
print(mathpack.simplemath.mul(1, 2))
print(mathpack.simplemath.div(1, 2))

# ========================================================================

И это СЛОЖНО. Если модифицировать импорт следующим образом:

from mathpack import simplemath

Тогда в остальном коде ничего не придется менять.
# ========================================================================

worker_pack_from.py

from mathpack import simplemath

print("\"import\" sample")
print(simplemath.add(1, 2))
print(simplemath.sub(1, 2))
print(simplemath.mul(1, 2))
print(simplemath.div(1, 2))

# ========================================================================

Детальный разбор механики модулей и пакетов.

Работа импорта.
Работа процедуры импорта модуля включает три шага:
= поиск модуля,
= компиляция,
= запуск.

Поиск модуля, указанного в импорте, интерпретатор Python, выполняет
последовательно в ряде директорий, список которых определен в рамках Module Search Path.
Этот список выглядит так:

= домашняя директория;
= директории, указанные в переменной окружения PYTHONPATH;
= директории Standard library;
= пути прописанные в .pth файлах;
= пакеты сторонних разработчиков.

Домашняя директория – это место, откуда выполняется скрипт.
Например, если файлы simplemath.py и worker.py
лежат в директории J:\work, то при запуске скрипта worker.py:

>python j:\work\worker.py
В качестве домашней директории будет выступать  J:\work.

Переменная окружения PYTHONPATH задается также как любая другая переменная
окружения в используемой операционной системе. В ней перечисляются пути,
по которым может находиться модуль, указанный в импорте.
Например, если модуль simplemath.py, перенести в каталог J:\work\sm,
то попытка запустить worker.py завершится неудачей, т.к.
не будет найден модуль simplemath.py. После добавления пути J:\work\sm
в PYTHONPATH  после перезапуска пользовательского сеанса, все будет работать.
При установке Python компьютере вместе с интерпретатором устанавливается и
стандартная библиотека (Standard library). В ней и будет осуществляться
поиск модуля, если он не будет найден в рабочей директории и по путям из
переменной окружения PYTHONPATH.
Следующее место, где будет искать модуль интерпретатор Python, если не найдет
его в стандартной библиотеке – эти пути, прописанные в файлах с расширением .pth.
Это обычные текстовые файлы, в которых указываются пути,
по которым необходимо производить поиск модулей
(каждый путь должен начинаться с новой строки).
Данные файлы следует располагать в каталоге Python или в <python-dir>/lib/site-python.
Далее в примере будет удалена в своей системе переменную окружения PYTHONPATH,
созданная ранее (если она используется, из неё можно убрать добавленный нами
путь J:\work\sm).
После этого можно создать в директории C:\Python35-32 файл workerpath.pth
со следующим содержимым.

workerpath.pth

j:\work\sm

И этого будет достаточно, чтобы скрипт worker.py запустился удачно.

Ну и последняя на очереди директория, в которой будет осуществляться поиск
импортированного модуля – это lib/site-packages. Обычно в ней располагаются
пакеты от сторонних разработчиков, устанавливаемые средствами Python.

После того, как модуль был найден, если это необходимо, производится
его компиляция в байт-код. Это делается в том случае, если байт-код более старый
по сравнению с файлом с исходным кодом (или запускается в другом интерпретаторе).
В Python 3 после компиляции создается каталог с именем __pycache__, и в нём
располагаются файлы с расширением .pyc. В них содержится байт-код.

После этого следует процедура запуска модуля, которая заключается в последовательном
выполнении строк кода в соответствующем модуле. Важно, что модуль импортируется
только один раз, при этом, и если еще раз выполнить процедуру импорта,
то модуль загружен НЕ будет. Можно перезагрузить модуль с помощью команды imp.reload.

Модули...
Создание и импортирование
Модули – это файлы с расширением .py.
Если модуль импортировать  с помощью import, то можно получить доступ к глобальным
переменным модуля и его функциями.

Например, если импортируется модуль с именем module.

import module

И в нём содержится глобальная переменная value и функция calc_value(),
то к ним можно получить доступ так.

module.value            # доступ к переменной
module.calc_value()     # доступ к функции

Это похоже на взаимодействие с объектами классов,
когда получается доступ к атрибутам и методам объекта.
Имена модулей надо выбирать также как имена переменных,
иначе их нельзя будет импортировать (!!!).
Так, если назвать модуль while.py, то импортировать его будет нельзя.

Как можно импортировать модули...
Для примера используется модуль simplemath.py, который был ранее создан.

1. Первый способ импорта модуля

import simplemath

Для доступа к элементам simplemath необходимо использовать имя модуля и далее,
через точку, как при работе с атрибутами классов, указывать переменные или функции.
Вот как при этом будет выглядеть вызов функции add():

simplemath.add(1, 2)

2. Второй способ импорта модуля

from simplemath import add

В этом случае функцию add() можно вызывать напрямую, без указания имени модуля.
При этом остальные функции из simplemath, такие как sub(), mul() и div()
будут недоступны (!!!).

3. Третий способ

from simplemath import *

Такой подход позволяет импортировать ВСЕ доступные элементы модуля
(переменные, функции, классы). И для работы с ними НЕ требуется
использовать имя модуля.

# ========================================================================
Важно, что import и from – это исполняемые выражения, и выполняются они
в процессе исполнения скрипта, а не на этапе компиляции.
Это позволяет гибко подходить к процессу импортирования:
использовать условные выражения и т.п.

Пример
Уже есть модуль simplemath.py. Создётся ещё один модуль с именем advmath.py.

advmath.py

def sqrt(value):
    return value**0.5

def pow(value, magn):
    return value**magn

Далее представленный скрипт запрашивает у пользователя,
какую математическую библиотеку следует загрузить.
При этом элементы из другой библиотеки будут недоступны.

selectimport.py

val = int(input("simple math lib [1], adv math lib [2]: "))
if val==1:
    import simplemath
    print(simplemath.add(1, 2))
elif val==2:
    import advmath
    print(advmath.sqrt(4))
else:
    print("Type only 1 or 2")

# ========================================================================
Теперь о модификации данных в импортируемых модулях.
Если импортируеncz модуль через оператор import, то в пространстве имен
программы появляется объект-модуль с соответствующим именем,
аргументы которого – это переменные в модуле.

Пример:

Создаётся модуль vars.py.

vars.py

value = 1
array = [1, 2, 3]

def set_value(new_value):
    value = new_value

def get_value():
    return value

В этом модуле содержатся две переменные (value и array) и
две функции (get_value() и set_value()), позволяющие модифицировать
и получать значение переменной value.

Если импортировать данный модуль с помощью import, то можно получить
следующие возможности:

= Доступ к переменным осуществляется через соответствующие атрибуты объекта-модуля.

import vars
vars.value
1

vars.array
[1, 2, 3]

= Вывоз функций организован как вызов методов объекта-модуля.

vars.get_value()
1

vars.set_value(5)
vars.get_value()
5

При этом можно менять значение переменных из модуля vars напрямую,
используя атрибуты.

vars.value = 7
vars.value
7

vars.array[2] = 17
vars.array
[1, 2, 17]

= Если же импортировать модуль vars через from, то работа с его элементами
будет отличаться от ранее описанного сценария:
переменные value и array будут скопированы в текущую область видимости.
Это приведет к тому, что для доступа к переменным из модуля vars теперь
НЕ нужно указывать имя модуля.

from vars import *
value
1

array
[1, 2, 3]

Но при этом переменная value – это уже новая переменная в текущей области видимости,
т.е. она находится вне контекста модуля vars.
Если дополнительно импортировать модуль через import, то модификация value в текущем
контексте НЕ затронет переменную value в модуле vars.
Импорт модуля vars через импорт и вывод значения value в нем.

import vars
vars.value
1

Модификация value в текущем контексте.

value = 9
value
9

vars.value
1

Так что это изменение НЕ коснулось value из модуля vars.
Теперь изменяется vars.value.

vars.value = 11
vars.value
11

value
9

Т.е. value и vars.value – это две разные переменные,
значения которых не связаны друг с другом.
Другое дело "мутабельные" переменные, в этом примере – это array.

array
[1, 2, 3]
vars.array
[1, 2, 3]

Пока значения совпадают, так и должно быть. После изменения array:

array[1] = 23
array
[1, 23, 3]
vars.array
[1, 23, 3]

То есть, изменение значения переменной array в текущем контексте
приводит к изменению этой переменной в контексте модуля vars.
Это связано с тем, что элементы этих списков ссылаются на одни и те же объекты.

Более подробно о том как устроены типы в Python см. тут
(https://devpractice.ru/python-lesson-3-data-model/).

Этот эффект наблюдается и в обратную сторону.

vars.array[0] = 15
vars.array
[15, 23, 3]
array
[15, 23, 3]

Если в программе импортируется сразу несколько модулей и есть вероятность
совпадения имен функций, классов или переменных в них, то лучше использовать import.

# ========================================================================
Перезагрузка модуля
После загрузки, модуль уже НЕ будет перезагружаться при повторном вызове import,
даже если внести в него какие-нибудь изменения. Вот примеры из предыдущего раздела.

Импорт модуля vars.

import vars
vars.value
1

Замена в файле vars.py строки value = 1 на value = 7.

# внесли изменения в vars.py
import vars
vars.value
1

То есть, ничего не поменялось.
Для перезагрузки модуля необходимо воспользоваться функцией reload() из модуля imp.

# внессти изменения в vars.py
import vars
vars.value
1

from imp import reload
reload(vars)
<module 'vars' from 'j:\\work\\vars.py'>
vars.value
7

Важно!
Всё, что импортируется из модуля можно получить через функцию dir().

import vars
dir(vars)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'array', 'get_value', 'set_value', 'value']

# ========================================================================
Пакеты...
Пакеты в Python можно воспринимать как каталоги, в которых лежат модули
(на самом деле все сложнее).  Для того, чтобы импортировать модуль из пакета,
необходимо в import передать весь путь до модуля с перечислением пакетов,
разделяя их точками.

Если перенести модуль vars.py (см. предыдущий раздел) в каталог simple,
то импорт будет выглядеть так:

import simple.vars
simple.vars.value
7

При этом для доступа к элементу value необходимо указывать всю иерархию вложения.
Для того, чтобы каталог стал пакетом в его "формальном" представлении
в python, необходимо в него поместить файл __init__.py.
Основное назначение этого файла – это предварительная инициализация пакета,
если она необходима. В самом простом случае – он может быть пустым.

Если в файле __init__.py есть какой-то код,
то он будет выполнен сразу после выполнения процедуры импорта.

# ========================================================================

Пакеты...
Установка пакетов в Python
В процессе разработки программного обеспечения на python часто возникает
необходимость воспользоваться пакетом, который в данный момент отсутствует
на компьютере.
О том, откуда взять нужный вам пакет и как его установить.

# ========================================================================
= Где взять отсутствующий пакет?
= Менеджер пакетов в Python – pip
= Установка pip
= Обновление pip
= Использование pip
    = Установка пакета
    = Удаление пакета
    = Обновление пакетов
    = Просмотр установленных пакетов
    = Поиск пакета в репозитории
    = Где еще информация о работе с pip?

Где взять отсутствующий пакет?

если надо работать над задачей "за рамками базового функционала"
который предоставляет python, например,
работа с web,
обработка изображений,
криптография и т.п. ,
необходимость в установке дополнительного пакета возникнет очень быстро.
В этом случае, необходимо:
= узнать, какой пакет содержит необходимый функционал,
= найти его,
= скачать,
= разместить в нужном каталоге,
= начать использовать.

Все эти действия можно сделать вручную, но этот процесс поддается автоматизации.
К тому же скачивать пакеты с неизвестных сайтов может быть довольно опасно.

В python, все эти задачи решены: для этого существует Python Package Index (PyPI)
– это репозиторий, открытый для всех python разработчиков, и в нем можно
найти пакеты для решения практически любых задач.
Там также есть возможность выкладывать свои пакеты.
Для скачивания и установки используется специальная утилита, которая называется pip.

# ========================================================================
Менеджер пакетов в Python – pip
pip – это консольная утилита (без графического интерфейса). После того, как как она
будет скачана и установлена, она прописывается в PATH и становится доступна
для использования.

Эту утилиту можно запускать как самостоятельно:

pip <аргументы>

так и через интерпретатор Python:

> python -m pip <аргументы>

Ключ -m означает, что запускается модуль (в данном случае pip).

Установка pip
При развертывании современной версии Python (начиная с Python 2.7.9 и Python 3.4),
pip устанавливается автоматически. Но если, по какой-то причине, pip не установлен ,
то сделать это можно вручную. Существует несколько способов.

1. Универсальный способ
Если Python у вас уже установлен и нужно установить pip, то для этого
надо скачать скрипт get-pip.py

curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py

и выполнить его.

python get-pip.py

При этом, вместе с pip будут установлены setuptools и wheels.
Setuptools  – это набор инструментов для построения пакетов Python.
Wheels – это формат дистрибутива для пакета Python...

Для Windows команда установки будет следующей:

python -m pip install -U pip

Использование pip
Далее - основные варианты использования pip:
1. установка пакетов,
2. удаление,
3. обновление пакетов.

Установка пакета
Pip позволяет установить самую последнюю версию пакета, конкретную версию
или воспользоваться логическим выражением, через которое можно определить,
что нужна версия не ниже указанной.
Также есть поддержка установки пакетов из репозитория.
Как использовать эти варианты...

Установка...
Установка последней версии пакета
> pip install ProjectName

Установка определенной версии
> pip install ProjectName==3.2

Установка пакета с версией не ниже 3.1
> pip install ProjectName>=3.1

Установка Python пакета из git репозитория
> pip install -e git+https://gitrepo.com/ProjectName.git

Установка из альтернативного индекса
> pip install --index-url http://pypackage.com/ ProjectName

Установка пакета из локальной директории
> pip install ./dist/ProjectName.tar.gz

Удаление...
Для удаления пакета имеется команда uninstall

> pip uninstall ProjectName

Обновление пакетов...
Для обновления пакета используется ключ –upgrade.

> pip install --upgrade ProjectName

Просмотр установленных пакетов ...
Для вывода списка всех установленных пакетов применяется команда pip list.

> pip list

Аргумент show позволяет получить более подробную информацию о конкретном пакете.

> pip show ProjectName

Поиск пакета в репозитории...
Если точное название пакета не известно, или надо посмотреть на пакеты,
содержащие конкретное слово, то можете это сделать, применив аргумент search.

> pip search "test"


"""


# This is a sample Python script.

# Press Shift+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.


def f1(x,y):
    return(x*y)

def print_hi(key):
    # Use a breakpoint in the code line below to debug your script.
    print(f'This is print_hi:  {key}')
    print(f1('asd ', 5))

def main(key):
    print_hi(key)


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    print_hi('PyCharm')

# See PyCharm help at https://www.jetbrains.com/help/pycharm/
