"""
Реализовать модуль divisor_master.
Все функции модуля принимают на вход натуральные числа от 1 до 1000.
Модуль содержит функции:
1. проверка числа на простоту (простые числа - это те числа у которых
   делители единица и они сами);
2. выводит список всех делителей числа;
3. выводит самый большой простой делитель числа.

"""

# Это МОДУЛЬ(!) так что здесь без вызовов и прочих прибамбасов...

# число i является делителем числа n, если i делит n без остатка.
# натуральное число n называется простым, если у него ровно два делителя:
# 1 и само число n.
# 2 — наименьшее простое число.
# 1 является множителем каждого числа.
# Каждое число n само по себе является множителем.

# таким образом, 1 и n — ТРИВИАЛЬНЫЕ множители для любого числа n.
# И у простого числа не должно быть других делителей, кроме этих двух (!!!).
# Это означает, что при переходе от 2 к n – 1 у простого числа невозможно
# найти НЕТРИВИАЛЬНЫЙ множитель, который делит n без остатка.
#
# Алгоритм 1 для проверки того, является ли число n простым
#
# Перебрать все числа от 2 до n – 1, используя объект range() в Python.
# range(start, stop, step) возвращает объект диапазона.
# Затем можно выполнить итерацию по объекту диапазона, чтобы получить
# последовательность от начала до конца n-1 с шагом 1.
#
# Поскольку нужен набор целых чисел от 2 до n-1, можно указать диапазон (2, n)
# и использовать его вместе с циклом for.
#
# И вот что при этом нужно сделать:
#
# Если найдётся число, которое делит n нацело без остатка,
# можете сразу сделать вывод, что это число НЕ простое.
# Если при переборе всего диапазона чисел от 2 до n – 1 не было
# найдено числа, которое делит n без остатка, то это число простое.

# def is_prime(n):
#   for i in range(2,n):
#     if (n%i) == 0:
#       return False
#   return True
#
# Оптимизация функции Python is_prime()
# Единственный множитель n, который больше n/2, — это сам n.
# Таким образом, не нужно зацикливаться до n – 1.
# Вместо этого можно выполнить цикл только до n/2.
# Если при этом НЕ найдётся нетривиальный множитель до n/2, то и множителя
# больше n/2 не бует.
#
# Функция is_prime() для проверки факторов в диапазоне (2, n/2):
#
# def is_prime(n):
#   for i in range(2,int(n/2)):
#     if (n%i) == 0:
#       return False
#   return True

# функция is_prime() принимает в качестве аргумента положительное целое число n.
# Если будет найден множитель (2*i) в диапазоне (2, n-1), is_prime вернет False,
# так как число не является простым.
# is_prime вернет True, если при проходе всего цикла, не найдётся множителя.

# Можно оптимизировать приведенный выше код.
# Возможны следующие варианты:
#
#  = Все простые числа существуют в форме 6n ± 1, за исключением 2 и 3.
#    Следовательно, проверка делимости данного числа на 2 и 3, а затем
#    проверка каждого числа, имеющего форму 6n ± 1 ...
#    В следующем коде чтобы проверить, является ли данное число простым числом,
#    используется оптимизированный метод простой итерации.
#
#  def isitPrime(k):
#      if k==2 or k==3: return True
#      if k%2==0 or k<2: return False

#      for i in range(3, int(k**0.5)+1, 2):
#          if k%i==0:
#              return False
#
#      return True

#
#   Ещё один вариант оптимизации...
#   Каждое число n можно записать как n = a*b
#   Если n — полный квадрат, то a = b = √n.
#   Если a < b, то a < √n и b > √n.
#   Если a > b, то a > √n и b < √n.
#   В таком случае, вместо того, чтобы перебирать
#   все целые числа от 2 до n/2, можно выбирать до √n.
#   Этот процесс в основном устраняет избыточность, которая возникает,
#   когда больший множитель числа n кратен меньшему множителю, который
#   уже был повторен.
#
#   = Проверять, пока вместо проверки точного числа не будет достигнут
#     корень данного числа.
#
#
# Чтобы вычислить квадратный корень числа, надо импортровать встроенный
# математический модуль Python и используем функцию math.sqrt().
# Так как n может не быть "идеальным" квадратом, его придется привести
# к целому числу. Для преобразования var в int используется int(var).
# Поскольку функция range() по умолчанию исключает конечную точку диапазона,
# чтобы убедиться, что проверка действительно идёт до √n, к int(math.sqrt(n))
# добавляется + 1. Как-то так... int(math.sqrt(n))+1
#
#  Таким образом,
#
# import math
#
# def is_prime(n):
#   for i in range(2,int(math.sqrt(n))+1):
#     if (n%i) == 0:
#       return False
#   return True
#
#
# Заключение
#
# Наивные подходы.
#
# Чтобы проверить, является ли число простым, надо перебрать
# все числа в диапазоне (2, n-1). И если не найдено множителя, который делит
# n, то n — простое число.
#
#
# Поскольку единственный множитель n, превышающий n/2, — это само n,
# диапазон можно ограничить до n/2.
#
#
# Все простые числа существуют в форме 6n ± 1, за исключением 2 и 3.
# Следовательно, проверка делимости данного числа на 2 и 3, а затем
# проверка каждого числа, имеющего форму 6n ± 1 ...
#
# Оптимизированный подход.
#
# Поскольку множители числа встречаются парами,
# можно перебирать только до √n.

import math

def is_prime(n):
  for i in range(2,int(math.sqrt(n))+1):
    if (n%i) == 0:
      return False
  return True

# ========================================================================

def lst_divisor_alpha(n):

  lstD = []

  for i in range(1, n+1):
    if (n%i) == 0:
      lstD.append(f'{i} is divisor of {n}: {int(n/i)}')

  return lstD

# ========================================================================

def lst_divisor(n):

  lstD = []

  for i in range(1, n+1):
    if (n%i) == 0:
      lstD.append(i)

  return lstD

def lst_divisor_x(n, lstType):
  print(f'lst_divisor_x {n}, lstType {lstType}')
  lstD = []

  for i in range(1, n+1):
    if (n%i) == 0:
      if lstType == 1:
        lstD.append(i)
      else:
        lstD.append(f'{i} is divisor of {n}: {int(n / i)}')

  return lstD

# ========================================================================
def isMax(key):    # первый уровень.
  # key == 0 lst_divisor возвращает список строк
  # key == 1 lst_divisor возвращает список целых

    def maxDecorator(func): # декоратор функции, которая сравнивает
                            # значения oldVal, newVal и возвращает БОЛЬШЕЕ

      def _wrapper(*args, **kwargs):  # изменение поведения
                                      # декорируемой функции
                                      # **kwargs определяет способ заполнения
                                      # списка: либо строки (0), либо целые (1)

        #print(f'_wrapper')

        ret = func(*args, **kwargs)

        #print(f'{ret}')

        if ret == True:
          return args[0][1]
        else:
          return args[0][0]


      return _wrapper
    return maxDecorator


# 0 lst_divisor возвращает список строк
# 1 lst_divisor возвращает список целых
@isMax(1)
def max_prime_divisor(argsLst):
  print(f'prime_divisor is here {argsLst[0]}, {argsLst[1]}')
  if argsLst[0] < argsLst[1]:
    return True
  else:
    return False
